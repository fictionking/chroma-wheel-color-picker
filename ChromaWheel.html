<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaWheel Color Picker</title>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <style>
        /* 全局样式 */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #b4b4b4;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }

        /* 颜色变量 */
        :root {
            --primary: #3B82F6;
            --secondary: #10B981;
            --neutral: #64748B;
            --dark: #1E293B;
            --light: #F8FAFC;
        }

        /* 工具类 */
        .content-auto {
            content-visibility: auto;
        }

        .color-transition {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }

        .transform-transition {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* 亮度环样式 */
        .lightness-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: auto;
        }

        /* 亮度环标记 - 调整大小与环的宽度匹配 */
        .ring-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            z-index: 10;
        }

        /* 颜色圆盘标记 */
        .wheel-marker {
            position: absolute;
            width: 14px;
            height: 14px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3);
            transform: translate(-50%, -50%);
            pointer-events: auto;
            z-index: 10;
        }

        /* 泪滴形状样式 */
        .teardrop-left-bottom {
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 50% 0;
            overflow: hidden;
        }

        .teardrop-right-bottom {
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 0 50%;
            overflow: hidden;
        }

        .teardrop-left-top {
            width: 30px;
            height: 30px;
            border-radius: 0 50% 50% 50%;
            overflow: hidden;
        }

        .teardrop-right-top {
            width: 30px;
            height: 30px;
            border-radius: 50% 0 50% 50%;
            overflow: hidden;
        }

        /* 预定义颜色 */
        .preset-color {
            position: absolute;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .preset-color:hover {
            transform: scale(1.1);
        }

        /* 收藏颜色 */
        .fav-color.filled {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.5);
            pointer-events: auto;
        }

        .fav-color.filled:hover {
            transform: scale(1.1);
        }

        .fav-color.notfill {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
            font-size: 12px;
            cursor: pointer;
            transition: border-color 0.2s ease;
            box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.2);
            border: 1px dashed #ffffff;
            pointer-events: auto;
        }

        .fav-color.notfill:hover {
            border-color: #9ca3af;
        }

        /* 主容器 */
        .main-container {
            background-color: #374151;
            border-radius: 12px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12);
            max-width: 400px;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        /* 标题栏 */
        .title-bar {
            padding: 12px 16px;
            border-bottom: 1px solid #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
        }

        .close-button {
            color: #9ca3af;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 12px;
            transition: color 0.3s ease;
        }

        .close-button:hover {
            color: #ffffff;
        }

        /* 颜色选择器容器 */
        .color-picker-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto;
            overflow: hidden;
        }

        /* 网格背景 */
        .grid-background {
            position: absolute;
            inset: 0;
            background-image: repeating-conic-gradient(#000000 0deg 90deg, #FFFFFF 90deg 180deg);
            background-size: 8px 8px;
            opacity: 0.05;
            z-index: 0;
        }

        /* 颜色选择器 */
        .color-selector {
            z-index: 5;
            position: absolute;
            left: 40px;
            top: 40px;
            width: 220px;
            height: 220px;
            filter: drop-shadow(0 0 6px rgba(0, 0, 0, 0.5));
        }

        /* 分段环弧容器 */
        .ring-container {
            position: absolute;
            left: 0;
            top: 0;
            width: 220px;
            height: 220px;
            overflow: hidden;
        }

        /* 彩色圆盘 */
        .color-wheel {
            position: absolute;
            left: 10px;
            top: 10px;
            width: 200px;
            height: 200px;
            overflow: hidden;
        }

        /* 颜色预览 */
        .color-preview {
            position: absolute;
            top: 8px;
            left: 7px;
            width: 66px;
            height: 66px;
            border-radius: 50%;
            overflow: hidden;
            z-index: 10;
            border: 0px solid #808080;
        }

        /* 初始颜色 */
        .color-start {
            position: absolute;
            top: 81px;
            left: 7px;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            overflow: hidden;
            z-index: 10;
            border: 0px solid #808080;
        }

        /* 收藏颜色容器 */
        .favorite-colors-bottom {
            position: absolute;
            left: 50%;
            bottom: 8px;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            z-index: 10;
        }

        .favorite-colors-right {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        /* 饱和度锁定按钮 */
        .lock-saturation {
            position: absolute;
            top: 30px;
            left: 142px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            color: #fff;
            background-color: #1f2937;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
            pointer-events: auto;
            box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .lock-saturation:hover {
            transform: scale(1.5);
        }

        /* 背景色切换区域 */
        .bg-color-slider {
            position: absolute;
            height: 64px;
            width: 16px;
            border-radius: 8px;
            cursor: pointer;
            top: 140px;
            left: 10px;
            background: linear-gradient(to bottom, #374151 0%, #374151 25%, #FFFFFF 25%, #FFFFFF 50%, #808080 50%, #808080 75%, #000000 75%, #000000 100%);
            box-shadow: 0 0 2px 2px rgba(0, 0, 0, 0.2);
            z-index: 10;
            transition: opacity 0.2s ease;
        }

        /* 颜色输入区 */
        .color-input-section {
            padding: 8px 16px 12px 16px;
        }

        .input-container {
            display: flex;
        }

        /* 颜色格式选择器 */
        .color-format-select {
            width: 64px;
            padding: 6px 8px;
            border: none;
            background-color: #1f2937;
            border-radius: 6px 0 0 6px;
            outline: none;
            font-size: 12px;
            color: #ffffff;
        }

        /* 移除焦点边框 */
        .color-format-select:focus {
            box-shadow: none;
            outline: none;
            border-color: transparent;
        }

        /* 颜色值输入框 */
        .color-value-input {
            flex: 1;
            padding: 6px 8px;
            border-left: none;
            border: 1px solid #374151;
            background-color: #1f2937;
            outline: none;
            font-size: 12px;
            color: #ffffff;
        }

        .color-value-input:focus {
            box-shadow: none;
            outline: none;
            border-color: transparent;
        }

        /* 复制按钮 */
        .copy-color-btn {
            background-color: #1f2937;
            border: 1px solid #374151;
            border-left: none;
            padding: 6px 8px;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 12px;
            color: #d1d5db;
        }

        .copy-color-btn:hover {
            background-color: #4b5563;
        }

        /* 复制成功提示 */
        .copy-toast {
            position: fixed;
            top: 16px;
            right: 16px;
            background-color: #1E293B;
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <!-- 主容器 -->
    <div class="main-container">
        <!-- 标题栏 -->
        <div class="title-bar">
            <h1 class="title">ChromaWheel Color Picker</h1>
        </div>
        <!-- 颜色选择器 -->
        <div id="color-picker-container" class="color-picker-container">
            <!-- 网格背景 - 应用于整个颜色选择器 -->
            <div class="grid-background"></div>
            <!-- 颜色选择区域 - 亮度环和色盘叠放 -->
            <div id="color-selector" class="color-selector">
                <!-- 分段环弧容器 - 位于底层 -->
                <div id="ring-container" class="ring-container">
                    <!-- 分段环弧将通过JS生成 -->
                    <!-- 饱和度环弧标记 -->
                    <div id="saturation-marker" class="ring-marker" title="饱和度"></div>
                    <!-- 亮度环弧标记 -->
                    <div id="lightness-marker" class="ring-marker" title="亮度"></div>
                    <!-- 透明度环弧标记 -->
                    <div id="alpha-marker" class="ring-marker" title="透明度"></div>
                </div>
                <!-- 彩色圆盘 - 位于上层 -->
                <div id="color-wheel" class="color-wheel">
                    <!-- 颜色圆盘将通过JS生成 -->
                    <!-- 颜色圆盘标记 -->
                    <div id="wheel-marker" class="wheel-marker" title="色相"></div>
                </div>
            </div>
            <!-- 圆形颜色预览 - 位于左上角 -->
            <div id="color-preview" class="color-preview"></div>
            <!-- 圆形初始颜色 - 位于左上角 -->
            <div id="color-start" class="color-start"></div>
            <svg style="z-index: 11;position:absolute;left: -2px;top: -1px;filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.5));pointer-events: none;"
                width="83.6" height="123.5" viewBox="0 0 83.6 123.5" fill="none">
                <path
                    d="M41.823 5C62.1614 5 78.6479 21.448 78.6479 41.737C78.6479 54.418 72.2079 65.598 62.412 72.2L58.961 74.07L54.0405 76.08C50.828 78.11 47.9152 81.555 46.0588 85.938C44.2025 90.318 43.7605 94.807 44.5413 98.52L44.6205 100.142L44.5533 103.003C42.7371 111.86 34.8798 118.527 25.4628 118.527C14.6987 118.527 5.9753 109.821 5.9753 99.085C5.9753 96.399 6.52058 93.84 7.50786 91.514L8.413 90.176L9.55165 88.817C12.1978 86.092 14.2206 82.062 14.9953 77.369C16.158 70.33 13.9749 65.288 10.3626 60.524L7.89476 56.037C6.02938 51.642 5 46.809 5 41.737C5 21.448 21.4875 5 41.823 5ZM42.0324 11.8275C25.6214 11.8275 12.3184 25.0995 12.3184 41.4715C12.3184 57.8435 25.6214 71.1155 42.0324 71.1155C58.4424 71.1155 71.7454 57.8435 71.7454 41.4715C71.7454 25.0995 58.4424 11.8275 42.0324 11.8275ZM25.5844 84.6255C17.8804 84.6255 11.6354 90.8555 11.6354 98.5415C11.6354 106.228 17.8804 112.459 25.5844 112.459C33.2884 112.459 39.5334 106.228 39.5334 98.5415C39.5334 90.8555 33.2884 84.6255 25.5844 84.6255Z"
                    stroke="rgba(100, 100, 100, 0.5)" stroke-width="2" fill-rule="evenodd" fill="url(#linear_fill_0_8)">
                </path>
                <defs>
                    <linearGradient id="linear_fill_0_8" x1="-1.0936279296875" y1="32.566619873046875"
                        x2="78.64790344238281" y2="79.79045104980469" gradientUnits="userSpaceOnUse">
                        <stop offset="0" stop-color="#CCCCCC" />
                        <stop offset="0.2838" stop-color="#F2F2F2" stop-opacity="1" />
                        <stop offset="0.5698" stop-color="#393939" stop-opacity="1" />
                        <stop offset="0.8342" stop-color="#A6A6A6" stop-opacity="1" />
                        <stop offset="1" stop-color="#E0E0E0" />
                    </linearGradient>
                </defs>
            </svg>


            <!-- 预定义颜色 - 右上角 -->
            <div class="preset-color teardrop-right-bottom" style="right:40px;top:5px;"></div>
            <div class="preset-color teardrop-left-bottom" style="right:5px;top:5px;"></div>
            <div class="preset-color teardrop-left-top" style="right:5px;top:40px;"></div>

            <!-- 预定义颜色 - 右下角 -->
            <div class="preset-color teardrop-left-bottom" style="right:5px;bottom: 40px;"></div>
            <div class="preset-color teardrop-left-top" style="right:5px;bottom: 5px;"></div>
            <div class="preset-color teardrop-right-top" style="right:40px;bottom: 5px;"></div>

            <!-- 预定义颜色 - 左下角 -->
            <div class="preset-color teardrop-left-top" style="left: 40px;bottom: 5px;"></div>
            <div class="preset-color teardrop-right-top" style="left: 5px;bottom: 5px;"></div>
            <div class="preset-color teardrop-right-bottom" style="left: 5px;bottom: 40px;"></div>
            <!-- 收藏的颜色-底部 -->
            <div class="favorite-colors-bottom">
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
            </div>
            <!-- 收藏的颜色-右侧 -->
            <div class="favorite-colors-right">
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
                <div class="fav-color"></div>
            </div>

            <div id="lockSaturation" title="锁定饱和度" class="lock-saturation">
                <i class="fa fa-unlock" style="font-size:8px;"></i>
            </div>
            <!-- 背景色切换区域 -->
            <div id="bgColorSlider" class="bg-color-slider"></div>
        </div>

        <!-- 颜色输入区 -->
        <div class="color-input-section">
            <div class="input-container">
                <select id="color-format-select" class="color-format-select">
                    <option value="hex">HEX</option>
                    <option value="rgb">RGB</option>
                    <option value="rgba">RGBA</option>
                    <option value="hsl">HSL</option>
                    <option value="hsla">HSLA</option>
                </select>
                <input type="text" id="color-value-input" value="#3B82F6" class="color-value-input" />
                <button id="copy-color-btn" class="copy-color-btn">
                    <i class="fa fa-copy"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- 复制成功提示 -->
    <div id="copy-toast" class="copy-toast">
        <span>Copied!</span>
    </div>

</body>

<script>
    // 颜色转换工具函数
    const ColorUtils = {
        // HSL 转 RGB
        hslToRgb: (h, s, l) => {
            s /= 100;
            l /= 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l; // 灰色
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;

                r = hue2rgb(p, q, h / 360 + 1 / 3);
                g = hue2rgb(p, q, h / 360);
                b = hue2rgb(p, q, h / 360 - 1 / 3);
            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        },

        // RGB 转 HEX
        rgbToHex: (r, g, b) => {
            return `#${[r, g, b]
                .map(x => Math.round(x).toString(16).padStart(2, '0'))
                .join('')
                .toUpperCase()}`;
        },

        // RGB 转 HSL
        rgbToHsl: (r, g, b) => {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // 灰色
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }

                h *= 60;
            }

            return {
                h: Math.round(h),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        },

        // HEX 转 RGB
        hexToRgb: (hex) => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        },

        // RGB 转 RGBA
        rgbToRgba: (rgb, a = 100) => {
            return {
                r: rgb.r,
                g: rgb.g,
                b: rgb.b,
                a: a
            };
        },

        // RGBA 转字符串
        rgbaToString: (r, g, b, a) => {
            return `rgba(${r}, ${g}, ${b}, ${a / 100})`;
        },

        // 字符串转 RGBA
        stringToRgba: (str) => {
            const match = str.match(/^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(0|1|0\.\d+)\s*\)$/);
            if (match) {
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                const a = Math.round(parseFloat(match[4]) * 100);
                return { r, g, b, a };
            }
            return null;
        },

        // HSL 转 HSLA
        hslToHsla: (hsl, a = 100) => {
            return {
                h: hsl.h,
                s: hsl.s,
                l: hsl.l,
                a: a
            };
        },

        // HSLA 转字符串
        hslaToString: (h, s, l, a) => {
            return `hsla(${h}, ${s}%, ${l}%, ${a / 100})`;
        },

        // 字符串转 HSLA
        stringToHsla: (str) => {
            const match = str.match(/^hsla\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(0|1|0\.\d+)\s*\)$/);
            if (match) {
                const h = parseInt(match[1]);
                const s = parseInt(match[2]);
                const l = parseInt(match[3]);
                const a = Math.round(parseFloat(match[4]) * 100);
                return { h, s, l, a };
            }
            return null;
        },

        // 从圆盘位置计算HSL颜色
        positionToHsl: (x, y, centerX, centerY, radius) => {
            const dx = x - centerX;
            const dy = centerY - y;
            const distance = Math.min(Math.sqrt(dx * dx + dy * dy), radius);
            // 修正色相角度计算，使圆盘与滑块保持一致
            const angle = (Math.atan2(-dy, dx) * 180 / Math.PI + 360) % 360;

            return {
                h: angle,
                s: (distance / radius) * 100,
                l: 50
            };
        },

        // 通用颜色字符串解析函数，支持HEX、RGB、RGBA、HSL、HSLA格式
        // 确保返回包含完整的h、s、l、r、g、b、a属性的对象
        colorStringToObject: (colorStr) => {
            if (!colorStr || typeof colorStr !== 'string') {
                return null;
            }

            // 去除空格，便于解析
            colorStr = colorStr.trim().replace(/\s+/g, '');

            // 确保所有返回值都包含完整的属性
            const result = {
                h: 0,
                s: 0,
                l: 0,
                r: 0,
                g: 0,
                b: 0,
                a: 100
            };

            // 尝试解析HEX格式
            if (/^#[0-9A-Fa-f]{3,6}$/.test(colorStr)) {
                const rgb = ColorUtils.hexToRgb(colorStr);
                if (rgb) {
                    const hsl = ColorUtils.rgbToHsl(rgb.r, rgb.g, rgb.b);
                    if (hsl) {
                        return {
                            h: hsl.h || 0,
                            s: hsl.s || 0,
                            l: hsl.l || 0,
                            r: rgb.r || 0,
                            g: rgb.g || 0,
                            b: rgb.b || 0,
                            a: 100
                        };
                    }
                }
            }

            // 尝试解析RGB格式
            const rgbMatch = colorStr.match(/^rgb\((\d+),(\d+),(\d+)\)$/i);
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]) || 0;
                const g = parseInt(rgbMatch[2]) || 0;
                const b = parseInt(rgbMatch[3]) || 0;
                const hsl = ColorUtils.rgbToHsl(r, g, b);
                if (hsl) {
                    return {
                        h: hsl.h || 0,
                        s: hsl.s || 0,
                        l: hsl.l || 0,
                        r: r,
                        g: g,
                        b: b,
                        a: 100
                    };
                }
            }

            // 尝试解析RGBA格式
            const rgbaMatch = colorStr.match(/^rgba\((\d+),(\d+),(\d+),(0|1|0\.\d+)\)$/i);
            if (rgbaMatch) {
                const r = parseInt(rgbaMatch[1]) || 0;
                const g = parseInt(rgbaMatch[2]) || 0;
                const b = parseInt(rgbaMatch[3]) || 0;
                const a = Math.round(parseFloat(rgbaMatch[4]) * 100) || 100;
                const hsl = ColorUtils.rgbToHsl(r, g, b);
                if (hsl) {
                    return {
                        h: hsl.h || 0,
                        s: hsl.s || 0,
                        l: hsl.l || 0,
                        r: r,
                        g: g,
                        b: b,
                        a: a
                    };
                }
            }

            // 尝试解析HSL格式
            const hslMatch = colorStr.match(/^hsl\((\d+),(\d+)%?,(\d+)%?\)$/i);
            if (hslMatch) {
                const h = parseInt(hslMatch[1]) || 0;
                const s = parseInt(hslMatch[2]) || 0;
                const l = parseInt(hslMatch[3]) || 0;
                const rgb = ColorUtils.hslToRgb(h, s, l);
                if (rgb) {
                    return {
                        h: h,
                        s: s,
                        l: l,
                        r: rgb.r || 0,
                        g: rgb.g || 0,
                        b: rgb.b || 0,
                        a: 100
                    };
                }
            }

            // 尝试解析HSLA格式
            const hslaMatch = colorStr.match(/^hsla\((\d+),(\d+)%?,(\d+)%?,(0|1|0\.\d+)\)$/i);
            if (hslaMatch) {
                const h = parseInt(hslaMatch[1]) || 0;
                const s = parseInt(hslaMatch[2]) || 0;
                const l = parseInt(hslaMatch[3]) || 0;
                const a = Math.round(parseFloat(hslaMatch[4]) * 100) || 100;
                const rgb = ColorUtils.hslToRgb(h, s, l);
                if (rgb) {
                    return {
                        h: h,
                        s: s,
                        l: l,
                        r: rgb.r || 0,
                        g: rgb.g || 0,
                        b: rgb.b || 0,
                        a: a
                    };
                }
            }

            return null;
        },

        // 从HSL计算圆盘位置
        // l参数当前未使用，仅为保持函数名与参数的一致性及未来扩展
        hslToPosition: (h, s, l, centerX, centerY, radius) => {
            const radians = h * Math.PI / 180;
            const distance = (s / 100) * radius;

            // 修正Y轴方向，使圆盘与滑块保持一致
            return {
                x: centerX + distance * Math.cos(radians),
                y: centerY - distance * Math.sin(-radians)
            };
        }
    };

    /**
     * 创建色彩选择器的环形控件
     * @param {HTMLElement} element - 要渲染环形的DOM元素
     * @param {Object} currentColor - HSLA格式的基础颜色对象，包含.h, .s, .l, .a属性
     * @returns {Object} 返回包含canvas信息的对象
     */
    function createRing(element, currentColor = null) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = Math.min(element.clientWidth, element.clientHeight);
        const scale = 2;
        canvas.width = size * scale;
        canvas.height = size * scale;
        canvas.style.width = `${size}px`;
        canvas.style.height = `${size}px`;
        canvas.className = 'lightness-ring';
        canvas.style.zIndex = '0'; // 确保亮度环位于色盘下层

        // 只删除已经存在的canvas元素，保留其他元素如ring-marker
        const existingCanvases = element.querySelectorAll('canvas');
        existingCanvases.forEach(canvasEl => {
            element.removeChild(canvasEl);
        });
        element.appendChild(canvas);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const outerRadius = canvas.width / 2;
        const innerRadius = outerRadius * 0.87; // 环的宽度，设置为外半径的0.9倍，使内径大于色盘的外径

        // 定义三个分段环弧的起始角度和占用角度
        // 每个弧占用100度
        const segments = [
            { startAngle: 160, arcAngle: 100, type: 'saturation' },  // 160度到260度
            { startAngle: 280, arcAngle: 100, type: 'lightness' },   // -80度到20度（280度到380度，即280度到20度）
            { startAngle: 40, arcAngle: 100, type: 'alpha' }         // 40度到140度
        ];

        // 为每个分段绘制环弧
        segments.forEach(segment => {
            if (ctx.createConicGradient) {
                // 使用圆锥渐变创建环弧
                const gradient = ctx.createConicGradient(segment.startAngle * Math.PI / 180, centerX, centerY);

                // 声明起始颜色和结束颜色变量
                let startColor, endColor;

                // 根据环弧类型设置不同的渐变颜色
                if (segment.type === 'saturation') {
                    // 饱和度环弧：从基于当前h值的基色（固定s=100%）到灰色的渐变
                    // 为饱和度弧创建基于当前h值的基色（固定s=100%，l=50%）
                    const saturationBaseColor = ColorUtils.hslToRgb(currentColor.h, 100, 50);
                    startColor = `rgba(${saturationBaseColor.r}, ${saturationBaseColor.g}, ${saturationBaseColor.b}, 1)`;
                    endColor = 'rgba(128, 128, 128, 1)';
                    gradient.addColorStop(0, startColor);
                    gradient.addColorStop(segment.arcAngle / 360, endColor);
                    gradient.addColorStop((segment.arcAngle + 20) / 360, endColor);
                    gradient.addColorStop(1, startColor);
                } else if (segment.type === 'lightness') {
                    // 亮度环弧：从白色到黑色的渐变
                    const lightnessBaseColor = ColorUtils.hslToRgb(currentColor.h, currentColor.s, 50)
                    startColor = 'rgba(255, 255, 255, 1)'
                    endColor = 'rgba(0, 0, 0, 1)'
                    gradient.addColorStop(0, startColor);
                    gradient.addColorStop(segment.arcAngle / 720, `rgba(${lightnessBaseColor.r}, ${lightnessBaseColor.g}, ${lightnessBaseColor.b}, 1)`);
                    gradient.addColorStop(segment.arcAngle / 360, endColor);
                    gradient.addColorStop((segment.arcAngle + 20) / 360, endColor);
                    gradient.addColorStop(1, startColor);
                } else if (segment.type === 'alpha') {
                    // 透明度环弧：从透明到基色的渐变
                    startColor = `rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, 0)`
                    endColor = `rgba(${currentColor.r}, ${currentColor.g}, ${currentColor.b}, 1)`
                    gradient.addColorStop(0, startColor);
                    gradient.addColorStop(segment.arcAngle / 360, endColor);
                    gradient.addColorStop((segment.arcAngle + 20) / 360, endColor);
                    gradient.addColorStop(1, startColor);
                }

                // 创建一个封闭的圆角环弧图形
                const ringWidth = outerRadius - innerRadius;
                const circleRadius = ringWidth / 2; // 圆的半径为环宽度的一半
                const midRadius = innerRadius + circleRadius; // 圆心位于内外半径之间的中点

                // 计算起始点和结束点的角度（弧度）
                const startAngleRad = segment.startAngle * Math.PI / 180;
                const endAngleRad = (segment.startAngle + segment.arcAngle) * Math.PI / 180;

                // 计算起始点和结束点的圆心坐标
                const startPointX = centerX + midRadius * Math.cos(startAngleRad);
                const startPointY = centerY + midRadius * Math.sin(startAngleRad);
                const endPointX = centerX + midRadius * Math.cos(endAngleRad);
                const endPointY = centerY + midRadius * Math.sin(endAngleRad);

                // 创建一个封闭的路径
                ctx.beginPath();

                // 1. 绘制外圆弧（顺时针方向）
                ctx.arc(centerX, centerY, outerRadius, startAngleRad, endAngleRad);

                // 2. 绘制结束点的圆角（连接外圆和内圆）
                ctx.arc(endPointX, endPointY, circleRadius, endAngleRad, endAngleRad + Math.PI);

                // 3. 绘制内圆弧（逆时针方向）
                ctx.arc(centerX, centerY, innerRadius, endAngleRad, startAngleRad, true);

                // 4. 绘制起始点的圆角（连接内圆和外圆）
                ctx.arc(startPointX, startPointY, circleRadius, startAngleRad + Math.PI, startAngleRad);

                // 封闭路径
                ctx.closePath();

                // 应用渐变和模糊效果并填充
                ctx.fillStyle = gradient;
                ctx.fill();

            }
        });

        return {
            canvas,
            centerX: centerX / scale,
            centerY: centerY / scale,
            outerRadius: outerRadius / scale,
            innerRadius: innerRadius / scale
        };
    }

    // 创建颜色圆盘
    function createColorWheel(element) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const size = Math.min(element.clientWidth, element.clientHeight);
        const scale = 2;
        canvas.width = size * scale;
        canvas.height = size * scale;
        canvas.style.width = `${size}px`;
        canvas.style.height = `${size}px`;
        element.appendChild(canvas);

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = canvas.width / 2 * 0.8; // 缩小色盘，为色相环留出空间

        const imageData = ctx.createImageData(canvas.width, canvas.height);
        const pixels = imageData.data;

        for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
                const dx = x - centerX;
                const dy = centerY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= radius) {
                    // 复用positionToHsl函数计算HSL颜色值
                    const hsl = ColorUtils.positionToHsl(x, y, centerX, centerY, radius);

                    const rgb = ColorUtils.hslToRgb(hsl.h, hsl.s, hsl.l);
                    const index = (y * canvas.width + x) * 4;
                    pixels[index] = rgb.r;
                    pixels[index + 1] = rgb.g;
                    pixels[index + 2] = rgb.b;
                    pixels[index + 3] = 255;
                }
            }
        }

        ctx.putImageData(imageData, 0, 0);
        ctx.filter = 'blur(1px)';
        ctx.drawImage(canvas, 0, 0);
        ctx.filter = 'none';

        return {
            canvas,
            centerX: centerX / scale,
            centerY: centerY / scale,
            radius: radius / scale
        };
    }

    // 颜色选择器主逻辑
    document.addEventListener('DOMContentLoaded', () => {
        const colorWheel = document.getElementById('color-wheel');
        const wheelData = createColorWheel(colorWheel);
        const wheelMarker = document.getElementById('wheel-marker');

        const colorSelector = document.getElementById('color-selector');
        // 初始化分段环弧
        const ringContainer = document.getElementById('ring-container');
        let ringData = null;

        // DOM 元素
        const hueValue = document.getElementById('hue-value');

        const saturationMarker = document.getElementById('saturation-marker');
        const lightnessMarker = document.getElementById('lightness-marker');
        const alphaMarker = document.getElementById('alpha-marker');

        const colorPreview = document.getElementById('color-preview');

        const copyToast = document.getElementById('copy-toast');
        const presetElements = document.querySelectorAll('.preset-color');
        const colorFormatSelect = document.getElementById('color-format-select');
        const colorValueInput = document.getElementById('color-value-input');
        const copyColorBtn = document.getElementById('copy-color-btn');

        // 当前颜色状态
        // 同时保存RGB和HSL值，避免转换导致的精度损失
        let currentColor = {
            h: 240,    // 色相
            s: 100,    // 饱和度
            l: 50,     // 亮度
            a: 100,    // 透明度
            r: 0,      // 红色
            g: 0,      // 绿色
            b: 255     // 蓝色
        };

        // 初始颜色状态 - 用于恢复初始颜色
        let initialColor = { ...currentColor };

        // 初始颜色显示元素
        const colorStart = document.getElementById('color-start');

        // 预定义颜色表 - 仅支持字符串格式（HEX、RGB、RGBA、HSL、HSLA）
        const presetColors = [
            { value: '#FF0000', name: '红色' },             // HEX格式
            { value: 'rgb(0, 255, 0)', name: '绿色' },       // RGB格式
            { value: 'rgb(0, 0, 255)', name: '蓝色' }, // RGBA格式
            { value: 'hsl(60, 100%, 50%)', name: '黄色' },   // HSL格式
            { value: 'hsl(300, 100%, 50%)', name: '品红' }, // HSLA格式
            { value: 'hsl(180, 100%, 50%)', name: '青色' },  // 改为HSL字符串格式
            { value: 'hsl(45, 100%, 50%)', name: '橙色' },   // 改为HSL字符串格式
            { value: 'hsl(90, 100%, 50%)', name: '黄绿色' }, // 改为HSL字符串格式
            { value: 'hsl(270, 100%, 50%)', name: '紫色' }   // 改为HSL字符串格式
        ];

        // 更新预定义颜色表的UI - 仅支持字符串格式
        const updatePresetColorsUI = () => {
            presetElements.forEach((el, index) => {
                if (index < presetColors.length) {
                    const presetColor = presetColors[index];

                    // 直接使用字符串格式的颜色值
                    el.style.backgroundColor = presetColor.value;
                    el.title = presetColor.name; // 添加颜色名称提示
                    el.style.display = 'block';
                } else {
                    // 超出预定义颜色范围的元素隐藏
                    el.style.display = 'none';
                }
            });
        };

        // 根据当前颜色创建亮度环 - 使用固定亮度值(50%)计算基色，确保亮度环基于色盘位置的颜色
        const createRingWithCurrentColor = () => {
            ringData = createRing(ringContainer, currentColor);
        };

        // 更新颜色显示
        const updateColorDisplay = () => {
            const { h, s, l, a, r, g, b } = currentColor;
            const hex = ColorUtils.rgbToHex(r, g, b);

            // 在rgba格式中，RGB值不应该带百分号
            colorPreview.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${a / 100})`;

            // 更新初始颜色显示
            colorStart.style.backgroundColor = `rgba(${initialColor.r}, ${initialColor.g}, ${initialColor.b}, ${initialColor.a / 100})`;

            // 根据当前选择的格式更新输入框
            const format = colorFormatSelect.value;
            switch (format) {
                case 'hex':
                    colorValueInput.value = hex;
                    break;
                case 'rgb':
                    colorValueInput.value = `rgb(${r}, ${g}, ${b})`;
                    break;
                case 'rgba':
                    colorValueInput.value = ColorUtils.rgbaToString(r, g, b, a);
                    break;
                case 'hsl':
                    colorValueInput.value = `hsl(${h}, ${s}%, ${l}%)`;
                    break;
                case 'hsla':
                    colorValueInput.value = ColorUtils.hslaToString(h, s, l, a);
                    break;
            }
            createRingWithCurrentColor();
            updateMarkerPositions();
        };

        // 更新标记位置
        const updateMarkerPositions = () => {
            const { h, s, l, a } = currentColor;

            // 颜色圆盘标记
            const pos = ColorUtils.hslToPosition(
                h, s, l,
                wheelData.centerX, wheelData.centerY,
                wheelData.radius
            );
            wheelMarker.style.left = `${pos.x}px`;
            wheelMarker.style.top = `${pos.y}px`;
            wheelMarker.style.display = 'block';
            const wheelRgb = ColorUtils.hslToRgb(h, s, 50); // 使用固定亮度值50%，与色盘一致
            wheelMarker.style.backgroundColor = `rgb(${wheelRgb.r}, ${wheelRgb.g}, ${wheelRgb.b})`;

            // 确保ringData已初始化
            if (!ringData) return;

            // 为每个分段环弧添加标记，确保位置计算基于容器
            // 饱和度环弧标记 - 根据当前饱和度值计算角度位置
            const saturationAngle = 160 + (100 - s);
            const saturationDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
            const saturationPosX = ringData.centerX + Math.cos(saturationAngle * Math.PI / 180) * saturationDistanceFromCenter;
            const saturationPosY = ringData.centerY + Math.sin(saturationAngle * Math.PI / 180) * saturationDistanceFromCenter;

            saturationMarker.style.left = `${saturationPosX}px`;
            saturationMarker.style.top = `${saturationPosY}px`;
            saturationMarker.style.display = 'block';

            // 亮度环弧标记 - 根据当前亮度值计算角度位置
            // 注意：因为亮度弧跨越了360度边界（280度到20度），需要特殊处理角度计算
            let lightnessAngle = 280 + (100 - l);
            if (lightnessAngle > 360) {
                lightnessAngle -= 360;
            }
            const lightnessDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
            const lightnessPosX = ringData.centerX + Math.cos(lightnessAngle * Math.PI / 180) * lightnessDistanceFromCenter;
            const lightnessPosY = ringData.centerY + Math.sin(lightnessAngle * Math.PI / 180) * lightnessDistanceFromCenter;

            lightnessMarker.style.left = `${lightnessPosX}px`;
            lightnessMarker.style.top = `${lightnessPosY}px`;
            lightnessMarker.style.display = 'block';

            // 透明度环弧标记 - 根据当前透明度值计算角度位置
            const alphaAngle = 40 + a;
            const alphaDistanceFromCenter = (ringData.innerRadius + ringData.outerRadius) / 2;
            const alphaPosX = ringData.centerX + Math.cos(alphaAngle * Math.PI / 180) * alphaDistanceFromCenter;
            const alphaPosY = ringData.centerY + Math.sin(alphaAngle * Math.PI / 180) * alphaDistanceFromCenter;

            alphaMarker.style.left = `${alphaPosX}px`;
            alphaMarker.style.top = `${alphaPosY}px`;
            alphaMarker.style.display = 'block';

            // 为所有标记设置当前最终输出颜色
            const rgb = ColorUtils.hslToRgb(h, s, l);
            saturationMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            lightnessMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
            alphaMarker.style.backgroundColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        }

        // 处理颜色圆盘交互
        let isDraggingWheel = false;
        let isDraggingRing = false;
        let isSaturationLocked = false; // 添加锁定饱和度状态变量

        // 为锁定饱和度图标添加点击事件
        const saturationLockBtn = document.getElementById('lockSaturation');
        if (saturationLockBtn) {
            saturationLockBtn.addEventListener('click', () => {
                isSaturationLocked = !isSaturationLocked;
                const lockIcon = saturationLockBtn.querySelector('i');
                lockIcon.className = isSaturationLocked ? 'fa fa-lock text-white' : 'fa fa-unlock text-white';
                lockIcon.style.fontSize = '8px';
            });
        }

        // 背景色切换功能
        const bgColorSlider = document.getElementById('bgColorSlider');
        const colorPickerContainer = document.getElementById('color-picker-container');

        // 背景色选项
        const bgColors = ['transparent', '#ffffff', '#808080', '#000000'];

        // 更新背景色
        const updateBackgroundColor = (index) => {
            const bgColor = bgColors[index];
            colorPickerContainer.style.backgroundColor = bgColor;
        };

        // 计算点击位置对应的索引
        const getBgColorIndex = (clientY) => {
            const rect = bgColorSlider.getBoundingClientRect();
            const y = clientY - rect.top;
            const relativeY = Math.max(0, Math.min(1, y / rect.height));
            return Math.floor(relativeY * bgColors.length);
        };

        // 点击事件处理
        bgColorSlider.addEventListener('click', (e) => {
            const index = getBgColorIndex(e.clientY);
            updateBackgroundColor(index);
        });

        // 触摸设备支持
        bgColorSlider.addEventListener('touchstart', (e) => {
            if (e.touches.length > 0) {
                const index = getBgColorIndex(e.touches[0].clientY);
                updateBackgroundColor(index);
                e.preventDefault();
            }
        });

        const handleWheelInteraction = (clientX, clientY) => {
            const rect = wheelData.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const hsl = ColorUtils.positionToHsl(
                x, y,
                wheelData.centerX, wheelData.centerY,
                wheelData.radius
            );

            // 同时更新HSL和RGB值
            const h = Math.round(hsl.h);
            const s = Math.round(hsl.s);
            const l = currentColor.l; // 保持当前亮度值
            currentColor.h = h;
            if (!isSaturationLocked) {
                currentColor.s = s; // 只有在饱和度未锁定时才更新s值
            }
            // 从HSL转换为RGB并更新
            const rgb = ColorUtils.hslToRgb(h, currentColor.s, l);
            currentColor.r = rgb.r;
            currentColor.g = rgb.g;
            currentColor.b = rgb.b;

            updateColorDisplay();
        };

        // 从亮度环位置计算亮度值 - 根据角度确定亮度值，连续渐变
        const getLightnessFromRingPosition = (clientX, clientY) => {
            const rect = ringData.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const dx = x - ringData.centerX;
            const dy = y - ringData.centerY;
            // 计算角度（0-360度）
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // 根据角度确定亮度值，连续渐变（0%到100%）
            const lightness = 100 - (angle / 360) * 100; // 亮度从100%到0%的连续变化

            // 限制在0-100范围内并四舍五入到整数
            return Math.round(Math.max(0, Math.min(100, lightness)));
        }


        // 从色盘位置检测是否在色彩区域内
        const isPositionInColorWheel = (clientX, clientY) => {
            const rect = wheelData.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;

            const dx = x - wheelData.centerX;
            const dy = y - wheelData.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 检查是否在色盘半径范围内
            return distance <= wheelData.radius * 1.1; // 添加一些容差范围
        }

        /**
         * 处理颜色选择器的交互事件（同时支持鼠标和触摸）
         * @param {Event} e - 事件对象
         * @param {boolean} isTouch - 是否为触摸事件
         */
        function handleColorSelectorInteraction(e, isTouch) {
            let clientX, clientY;

            if (isTouch) {
                if (e.touches.length === 0) return;
                const touch = e.touches[0];
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // 只有当鼠标按下位置在色盘色彩区域内时，才触发交互
            if (isPositionInColorWheel(clientX, clientY)) {
                isDraggingWheel = true;
                handleWheelInteraction(clientX, clientY);
                e.preventDefault();
                e.stopPropagation();
            } else {
                // 分段环弧交互
                const rect = ringData.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                if (handleRingInteraction(x, y)) {
                    e.preventDefault();
                    e.stopPropagation(); // 阻止事件冒泡到色盘
                }
            }
        }

        // 同时注册鼠标和触摸事件
        colorSelector.addEventListener('mousedown', (e) => handleColorSelectorInteraction(e, false));
        colorSelector.addEventListener('touchstart', (e) => handleColorSelectorInteraction(e, true));

        const updateColorByRingPostion = (x, y, currentDraggingSegmentType) => {

            // 根据鼠标按下时确定的环弧类型和当前角度计算值
            const value = getValueFromSegmentPosition(x, y, currentDraggingSegmentType);
            if (value !== null) {
                // 获取当前颜色的HSL值
                const { h, s, l } = currentColor;

                if (currentDraggingSegmentType === 'saturation') {
                    currentColor.s = value;
                    // 更新RGB值
                    const rgb = ColorUtils.hslToRgb(h, value, l);
                    currentColor.r = rgb.r;
                    currentColor.g = rgb.g;
                    currentColor.b = rgb.b;
                } else if (currentDraggingSegmentType === 'lightness') {
                    currentColor.l = value;
                    // 更新RGB值
                    const rgb = ColorUtils.hslToRgb(h, s, value);
                    currentColor.r = rgb.r;
                    currentColor.g = rgb.g;
                    currentColor.b = rgb.b;
                } else if (currentDraggingSegmentType === 'alpha') {
                    currentColor.a = value;
                    // 透明度不影响RGB值
                }
                updateColorDisplay();
            }
        }
        /**
         * 统一处理色盘选择器的移动事件（鼠标和触摸）
         * @param {Event} e - 事件对象
         * @param {boolean} isTouch - 是否为触摸事件
         */
        const handleColorSelectorMove = (e, isTouch) => {

            // 根据事件类型获取坐标
            const clientX = isTouch ? e.touches[0].clientX : e.clientX;
            const clientY = isTouch ? e.touches[0].clientY : e.clientY;

            if (isDraggingWheel) {
                // 处理色盘交互
                handleWheelInteraction(clientX, clientY);
                e.preventDefault();
                e.stopPropagation();
            } else if (isDraggingRing && currentDraggingSegmentType) {
                // 处理分段环弧交互
                const rect = ringData.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                updateColorByRingPostion(x, y, currentDraggingSegmentType);
                e.preventDefault();
                e.stopPropagation();
            }
        };

        // 注册鼠标移动事件
        document.addEventListener('mousemove', (e) => handleColorSelectorMove(e, false));
        document.addEventListener('touchmove', (e) => handleColorSelectorMove(e, true), { passive: false });

        // 鼠标释放事件
        /**
         * 统一处理鼠标/触摸释放事件，重置拖拽状态
         */
        const handleColorSelectorRelease = () => {
            isDraggingWheel = false;
            isDraggingRing = false;
            currentDraggingSegmentType = null;
        };

        // 注册释放事件
        document.addEventListener('mouseup', handleColorSelectorRelease);
        document.addEventListener('touchend', handleColorSelectorRelease);

        // 定义三个分段环弧的起始角度和占用角度
        const segments = [
            { startAngle: 160, arcAngle: 100, type: 'saturation' },  // 160度到260度
            { startAngle: 280, arcAngle: 100, type: 'lightness' },   // -80度到20度（280度到380度，即280度到20度）
            { startAngle: 40, arcAngle: 100, type: 'alpha' }         // 40度到140度
        ];

        // 检查点击位置是否在某个环弧上，并返回对应的环弧类型
        const getSegmentTypeAtPosition = (x, y) => {
            const centerX = ringData.centerX;
            const centerY = ringData.centerY;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // 检查是否在环的宽度范围内
            if (distance < ringData.innerRadius * 0.9 || distance > ringData.outerRadius * 1.1) {
                return null;
            }

            // 计算点击位置的角度
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // 检查点击位置属于哪个环弧
            for (const segment of segments) {
                const endAngle = segment.startAngle + segment.arcAngle;

                // 处理跨越360度边界的情况
                if (endAngle > 360) {
                    // 对于跨越360度边界的环弧（如亮度弧：280度到380度即280度到20度）
                    if ((angle >= segment.startAngle - 5 && angle <= 360) || (angle >= 0 && angle <= endAngle - 360 + 5)) {
                        return segment.type;
                    }
                } else {
                    // 普通环弧（不跨越360度边界）
                    if (angle >= segment.startAngle - 5 && angle <= endAngle + 5) {
                        return segment.type;
                    }
                }
            }

            return null;
        };

        // 从环弧位置计算对应的值
        const getValueFromSegmentPosition = (x, y, segmentType) => {
            const centerX = ringData.centerX;
            const centerY = ringData.centerY;
            const dx = x - centerX;
            const dy = y - centerY;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // 根据不同的环弧类型计算值
            for (const segment of segments) {
                if (segment.type === segmentType) {
                    // 计算在当前环弧中的相对位置
                    let relativePosition;
                    const endAngle = segment.startAngle + segment.arcAngle;

                    // 处理跨越360度边界的情况
                    if (endAngle > 360) {
                        if (angle >= segment.startAngle) {
                            // 角度在起始角度到360度之间
                            relativePosition = (angle - segment.startAngle) / segment.arcAngle;
                        } else {
                            // 角度在0度到结束角度减去360度之间
                            if (angle < segment.startAngle && angle <= 180) {
                                angle += 360;
                            }
                            relativePosition = (angle - segment.startAngle) / segment.arcAngle;
                        }
                    } else {
                        // 普通环弧（不跨越360度边界）
                        ag = angle - segment.startAngle
                        if (ag > 280) { //超过半个圆设为反方向
                            ag -= 360
                        }
                        relativePosition = ag / segment.arcAngle;
                    }
                    // 确保相对位置在0-1范围内
                    const clampedPosition = Math.max(0, Math.min(1, relativePosition));

                    // 根据环弧类型返回不同的值
                    if (segmentType === 'saturation') {
                        return Math.round((1 - clampedPosition) * 100); // 饱和度从100%到0%
                    } else if (segmentType === 'lightness') {
                        return Math.round((1 - clampedPosition) * 100); // 亮度从100%到0%
                    } else if (segmentType === 'alpha') {
                        return Math.round(clampedPosition * 100); // 透明度从0%到100%
                    }
                }
            }

            return null;
        };

        // 保存当前拖动的环弧类型
        let currentDraggingSegmentType = null;

        /**
         * 处理环弧交互的函数
         * @param {number} x - 相对于canvas的x坐标
         * @param {number} y - 相对于canvas的y坐标
         * @returns {boolean} - 是否处理了交互
         */
        function handleRingInteraction(x, y) {
            // 检查点击位置属于哪个环弧
            const segmentType = getSegmentTypeAtPosition(x, y);

            if (segmentType) {
                isDraggingRing = true;
                currentDraggingSegmentType = segmentType;
                updateColorByRingPostion(x, y, segmentType);
                return true;
            }
            return false;
        }


        // 颜色格式选择器事件
        colorFormatSelect.addEventListener('change', () => {
            updateColorDisplay();
        });

        // 处理颜色值输入的函数
        function processColorInput(value) {
            // 复用colorStringToObject函数解析所有格式的颜色值
            const parsedColor = ColorUtils.colorStringToObject(value);

            if (parsedColor) {
                // 更新currentColor的所有属性
                currentColor.h = parsedColor.h;
                currentColor.s = parsedColor.s;
                currentColor.l = parsedColor.l;
                currentColor.r = parsedColor.r;
                currentColor.g = parsedColor.g;
                currentColor.b = parsedColor.b;
                currentColor.a = parsedColor.a || 100;

                updateColorDisplay();
            } else {
                // 如果输入无效，重置显示
                updateColorDisplay();
            }
        }

        // 新的颜色值输入框事件处理 - 失去焦点时
        colorValueInput.addEventListener('blur', (e) => {
            processColorInput(e.target.value);
        });

        // 新的颜色值输入框事件处理 - 按下回车键时
        colorValueInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                processColorInput(e.target.value);
                // 阻止默认行为，避免回车键在某些情况下可能导致的表单提交
                e.preventDefault();
            }
        });

        // 复制按钮功能
        copyColorBtn.addEventListener('click', () => {
            colorValueInput.select();
            document.execCommand('copy');

            copyToast.style.opacity = '1';
            setTimeout(() => {
                copyToast.style.opacity = '0';
            }, 2000);
        });

        // 预定义颜色点击事件 - 仅支持字符串格式
        presetElements.forEach((colorEl, index) => {
            colorEl.addEventListener('click', () => {
                if (index < presetColors.length) {
                    const presetColor = presetColors[index];

                    // 解析字符串格式的颜色值
                    const parsedColor = ColorUtils.colorStringToObject(presetColor.value);
                    if (parsedColor) {
                        // 更新currentColor的所有属性
                        currentColor.h = parsedColor.h;
                        currentColor.s = parsedColor.s;
                        currentColor.l = parsedColor.l;
                        currentColor.r = parsedColor.r;
                        currentColor.g = parsedColor.g;
                        currentColor.b = parsedColor.b;
                        currentColor.a = parsedColor.a || 100;
                    }

                    updateColorDisplay();
                }
            });
        });

        // 点击恢复初始颜色
        colorStart.addEventListener('click', () => {
            // 复制初始颜色到当前颜色
            currentColor = { ...initialColor };
            // 更新显示
            updateColorDisplay();
        });

        // 收藏颜色功能实现
        // 1. 初始化收藏颜色数组，存储HEX格式的颜色值
        const favoriteColors = [];
        const STORAGE_KEY = 'colorPickerFavoriteColors';

        // 从localStorage加载收藏颜色
        function loadFavoriteColorsFromStorage() {
            try {
                const storedColors = localStorage.getItem(STORAGE_KEY);
                if (storedColors) {
                    const parsedColors = JSON.parse(storedColors);
                    for (let i = 0; i < 10; i++) {
                        favoriteColors[i] = parsedColors[i] || null;
                    }
                } else {
                    // 首次使用，初始化为空
                    for (let i = 0; i < 10; i++) {
                        favoriteColors[i] = null;
                    }
                }
            } catch (error) {
                console.error('加载收藏颜色失败:', error);
                // 出错时全部初始化为空
                for (let i = 0; i < 10; i++) {
                    favoriteColors[i] = null;
                }
            }
        }

        // 保存收藏颜色到localStorage
        function saveFavoriteColorsToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(favoriteColors));
            } catch (error) {
                console.error('保存收藏颜色失败:', error);
            }
        }

        // 2. 获取所有收藏颜色元素
        const favColorElements = document.querySelectorAll('.fav-color');

        // 3. 更新收藏颜色UI显示
        function updateFavoriteColorsUI() {
            favColorElements.forEach((el, index) => {
                if (!el) return;

                // 清空元素内的内容
                el.innerHTML = '';
                el.className = '';

                if (favoriteColors[index]) {
                    // 有收藏色的样式
                    el.className = 'fav-color filled';
                    el.style.backgroundColor = favoriteColors[index];
                    el.title = '右键或拖出删除';

                    // 启用拖出删除功能
                    el.draggable = true;
                } else {
                    // 无收藏色的样式
                    el.className = 'fav-color notfill';
                    el.style.backgroundColor = '';
                    el.title = '点击添加当前颜色';

                    // 添加加号图标
                    const plusIcon = document.createElement('i');
                    plusIcon.className = 'fa fa-plus';
                    el.appendChild(plusIcon);

                    // 禁用拖出功能
                    el.draggable = false;
                }
            });
        }

        // 4. 为收藏颜色元素添加点击事件
        favColorElements.forEach((el, index) => {
            if (!el) return;

            const elementClick = (index) => {
                if (favoriteColors[index]) {
                    // 点击有收藏色的收藏位，应用该颜色
                    const parsedColor = ColorUtils.colorStringToObject(favoriteColors[index]);
                    if (parsedColor) {
                        // 更新currentColor的所有属性
                        currentColor.h = parsedColor.h;
                        currentColor.s = parsedColor.s;
                        currentColor.l = parsedColor.l;
                        currentColor.r = parsedColor.r;
                        currentColor.g = parsedColor.g;
                        currentColor.b = parsedColor.b;
                        currentColor.a = parsedColor.a || 100;

                        // 更新所有UI显示
                        updateColorDisplay();
                    }
                } else {
                    // 点击空白收藏位，将当前颜色添加到该收藏位
                    // 保存为rgba格式
                    const currentRgba = ColorUtils.rgbaToString(currentColor.r, currentColor.g, currentColor.b, currentColor.a || 100);
                    favoriteColors[index] = currentRgba;
                    updateFavoriteColorsUI();
                    saveFavoriteColorsToStorage(); // 保存到本地存储
                }
            };
            el.addEventListener('click', () => {
                elementClick(index);
            });

            // 5. 添加右键点击删除功能
            el.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // 阻止默认右键菜单
                if (favoriteColors[index]) {
                    favoriteColors[index] = null;
                    updateFavoriteColorsUI();
                    saveFavoriteColorsToStorage(); // 保存到本地存储
                }
            });

            // 6. 添加拖出删除功能 - 桌面拖拽
            el.addEventListener('dragstart', (e) => {
                if (favoriteColors[index]) {
                    e.dataTransfer.setData('text/plain', index.toString());
                    // 设置拖拽时的透明度，提供视觉反馈
                    el.style.opacity = '0.5';
                }
            });

            el.addEventListener('dragend', () => {
                // 恢复元素透明度
                el.style.opacity = '1';
            });

            // 7. 添加触摸设备拖出删除功能
            let touchStartX = 0;
            let touchStartY = 0;
            let isDragging = false;
            const DRAG_THRESHOLD = 50; // 拖出阈值
            let draggedColorIndex = null;

            el.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (favoriteColors[index]) {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    isDragging = false;
                    draggedColorIndex = index;
                    // 记录当前元素的初始位置
                    el.dataset.originalTransform = el.style.transform || '';
                } else {
                    elementClick(index);
                }
            }, { passive: false });

            el.addEventListener('touchmove', (e) => {
                if (draggedColorIndex !== null && favoriteColors[draggedColorIndex]) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - touchStartX;
                    const dy = touch.clientY - touchStartY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 10) {
                        isDragging = true;
                        // 防止页面滚动
                        e.preventDefault();
                        // 跟随手指移动元素
                        el.style.transform = `translate(${dx}px, ${dy}px)`;
                        // 提供视觉反馈
                        el.style.opacity = '0.5';
                        el.style.zIndex = '100'; // 确保在最上层
                    }
                }
            }, { passive: false });

            el.addEventListener('touchend', (e) => {
                if (draggedColorIndex !== null && favoriteColors[draggedColorIndex]) {
                    const touch = e.changedTouches[0];
                    const dx = touch.clientX - touchStartX;
                    const dy = touch.clientY - touchStartY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 恢复元素样式
                    el.style.transform = el.dataset.originalTransform;
                    el.style.opacity = '1';
                    el.style.zIndex = '';

                    // 如果拖动距离超过阈值，视为拖出删除
                    if (isDragging && distance > DRAG_THRESHOLD) {
                        favoriteColors[draggedColorIndex] = null;
                        updateFavoriteColorsUI();
                        saveFavoriteColorsToStorage(); // 保存到本地存储
                    } else {
                        elementClick(draggedColorIndex);
                    }

                    // 重置状态
                    isDragging = false;
                    draggedColorIndex = null;
                }
            });
        });

        // 8. 添加文档拖拽事件，实现拖出删除（桌面端）
        document.addEventListener('dragover', (e) => {
            e.preventDefault(); // 允许放置
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();
            const colorIndex = e.dataTransfer.getData('text/plain');
            if (colorIndex !== '' && !isNaN(parseInt(colorIndex))) {
                // 从收藏位置删除颜色
                favoriteColors[parseInt(colorIndex)] = null;
                updateFavoriteColorsUI();
                saveFavoriteColorsToStorage(); // 保存到本地存储
            }
        });
        // 初始化环
        createRingWithCurrentColor();
        // 初始设置为透明背景
        updateBackgroundColor(0);
        // 初始化预定义色
        updatePresetColorsUI();
        updateColorDisplay();
        // 初始化收藏颜色UI
        loadFavoriteColorsFromStorage(); // 先从localStorage加载
        updateFavoriteColorsUI();
    });
</script>

</html>